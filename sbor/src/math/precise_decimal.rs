use simple_bigint::bigint::{BigInt, BigIntError};

use crate::math::format_big_int;
use crate::static_vec::StaticVec;

#[derive(Copy, Clone)]
pub struct PreciseDecimal(BigInt<512>);

impl PreciseDecimal {
    pub const SCALE: usize = 64;
    pub const MAX_PRINT_LEN: usize = 160;
    pub const MAX: PreciseDecimal = PreciseDecimal(BigInt::from_limbs([
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0xFFFF_FFFF,
        0x7FFF_FFFF,
    ]));
    pub const MIN: PreciseDecimal = PreciseDecimal(BigInt::from_limbs([
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x0000_0000,
        0x8000_0000,
    ]));

    pub fn is_negative(&self) -> bool {
        self.0.is_negative()
    }

    pub fn format<const N: usize>(&self, output: &mut StaticVec<u8, N>) {
        format_big_int::<512, { Self::SCALE }, N>(&self.0, output);
    }
}

impl TryFrom<&[u8]> for PreciseDecimal {
    type Error = BigIntError;
    fn try_from(value: &[u8]) -> Result<Self, BigIntError> {
        Ok(Self(BigInt::<512>::from_bytes(value)?))
    }
}

#[cfg(test)]
#[rustfmt::skip]
mod tests {
    use core::fmt;
    use core::fmt::Write;

    use super::*;

    impl fmt::Display for PreciseDecimal {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
            let mut formatted = StaticVec::<u8, { Self::MAX_PRINT_LEN }>::new(0);
            format_big_int::<512, { Self::SCALE }, { Self::MAX_PRINT_LEN }>(
                &self.0,
                &mut formatted,
            );

            for &byte in formatted.as_slice() {
                f.write_char(byte as char)?;
            }
            Ok(())
        }
    }

    #[test]
    pub fn test_format_decimal() {
        let one = PreciseDecimal(
            BigInt::<512>::from_bytes(&[
                0, 0, 0, 0, 0, 0, 0, 0, 1, 31, 106, 191, 100, 237, 56, 110, 237, 151, 167, 218,
                244, 249, 63, 233, 3, 79, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            ])
            .unwrap(),
        );

        assert_eq!(PreciseDecimal(1u128.into()).to_string(), "0.0000000000000000000000000000000000000000000000000000000000000001");
        assert_eq!(PreciseDecimal(123456789123456789u128.into()).to_string(), "0.0000000000000000000000000000000000000000000000123456789123456789");
        assert_eq!(one.to_string(), "1");
        assert_eq!(PreciseDecimal(123000000000000000000000000000000000000u128.into()).to_string(), "0.0000000000000000000000000123");
        assert_eq!(PreciseDecimal(123456789123456789000000000000000000000u128.into()).to_string(), "0.0000000000000000000000000123456789123456789");
        assert_eq!(PreciseDecimal(BigInt::<512>::from_bytes(&[
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0xbe, 0xe5, 0x18, 0xac,
                    0xe9, 0xdd, 0x1d, 0x50, 0xb6, 0x62, 0x06, 0x59, 0x92, 0x19, 0x4b, 0x9e, 0x2b,
                    0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]).unwrap()
            ).to_string(), "1.2");
        assert_eq!(PreciseDecimal::MAX.to_string(), "670390396497129854978701249910292306373968291029619668886178072186088201503677348840093714.9083451713845015929093243025426876941405973284973216824503042047");
        assert_eq!(PreciseDecimal::MIN.is_negative(), true);
        assert_eq!(PreciseDecimal::MIN.to_string(), "-670390396497129854978701249910292306373968291029619668886178072186088201503677348840093714.9083451713845015929093243025426876941405973284973216824503042048");
    }


    const PRECISE_DECIMAL_1: [u8; 66] = [
        0x5c, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1f, 0x6a, 0xbf, 0x64, 0xed, 0x38, 0x6e, 0xed, 0x97, 0xa7, 0xda, 0xf4, 0xf9, 0x3f, 0xe9, 0x03, 0x4f, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ];
    const PRECISE_DECIMAL_10: [u8; 66] = [
        0x5c, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x36, 0x25, 0x7a, 0xef, 0x45, 0x39, 0x4e, 0x46, 0xef, 0x8b, 0x8a, 0x90, 0xc3, 0x7f, 0x1c, 0x27, 0x16, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ];
    const PRECISE_DECIMAL_12: [u8; 66] = [
        0x5c, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x74, 0xf9, 0xf8, 0xb8, 0x20, 0xab, 0x2a, 0x21, 0x1f, 0xdb, 0x3f, 0x7a, 0xb7, 0xff, 0xee, 0x2e, 0xb4, 0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ];
    const PRECISE_DECIMAL_123: [u8; 66] = [
        0x5c, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b, 0xe5, 0xfc, 0xf7, 0x67, 0x0f, 0x5a, 0xf5, 0x13, 0xff, 0x85, 0x0e, 0xa5, 0x18, 0xbd, 0x11, 0xe1, 0xf6, 0xad, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ];
    const PRECISE_DECIMAL_1_23456789: [u8; 66] = [
        0x5c, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x80, 0x3c, 0x7b, 0xd2, 0x67, 0x9d, 0x6f, 0x51, 0xcf, 0x9c, 0x5b, 0x3b, 0xd6, 0xa1, 0x8a, 0x1e, 0xbc, 0x02, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ];
    const PRECISE_DECIMAL_0_23456789: [u8; 66] = [
        0x5c, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x7f, 0x1d, 0x11, 0x13, 0x03, 0xb0, 0x36, 0xe3, 0xe1, 0x04, 0xb4, 0x60, 0xe1, 0xa7, 0x4a, 0x35, 0xb8, 0xb3, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ];

    #[test]
    fn test_decoding_decimal() {
        assert_eq!(PreciseDecimal::try_from(&PRECISE_DECIMAL_1[2..]).unwrap().to_string(), "1");
        assert_eq!(PreciseDecimal::try_from(&PRECISE_DECIMAL_10[2..]).unwrap().to_string(), "10");
        assert_eq!(PreciseDecimal::try_from(&PRECISE_DECIMAL_12[2..]).unwrap().to_string(), "12");
        assert_eq!(PreciseDecimal::try_from(&PRECISE_DECIMAL_123[2..]).unwrap().to_string(), "123");
        assert_eq!(PreciseDecimal::try_from(&PRECISE_DECIMAL_1_23456789[2..]).unwrap().to_string(), "1.23456789");
        assert_eq!(PreciseDecimal::try_from(&PRECISE_DECIMAL_0_23456789[2..]).unwrap().to_string(), "0.23456789");
    }
}
